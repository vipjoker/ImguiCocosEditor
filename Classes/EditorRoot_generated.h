// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EDITORROOT_EDITOR_H_
#define FLATBUFFERS_GENERATED_EDITORROOT_EDITOR_H_

#include "flatbuffers/flatbuffers.h"

namespace Editor {

    struct EditorRoot;
    struct EditorRootT;

    struct NodeTree;
    struct NodeTreeT;

    struct Sprite;
    struct SpriteT;

    struct Label;
    struct LabelT;

    struct Button;
    struct ButtonT;

    struct Body;
    struct BodyT;

    struct Fixture;
    struct FixtureT;

    struct Joint;
    struct JointT;

    struct Vec4b;

    struct Vec4f;

    struct Vec2f;

    struct Sizef;

    enum NodeType {
        NodeType_BUTTON = 0,
        NodeType_SPRITE = 1,
        NodeType_LAYOUT = 2,
        NodeType_LABEL = 3,
        NodeType_UI_SCROLL_VIEW = 4,
        NodeType_UI_LIST_VIEW = 5,
        NodeType_MIN = NodeType_BUTTON,
        NodeType_MAX = NodeType_UI_LIST_VIEW
    };

    inline NodeType (&EnumValuesNodeType())[6] {
            static NodeType values[] = {
                NodeType_BUTTON,
                        NodeType_SPRITE,
                        NodeType_LAYOUT,
                        NodeType_LABEL,
                        NodeType_UI_SCROLL_VIEW,
                        NodeType_UI_LIST_VIEW
            };
            return values;
    }

    inline const char **EnumNamesNodeType() {
        static const char *names[] = {
                "BUTTON",
                "SPRITE",
                "LAYOUT",
                "LABEL",
                "UI_SCROLL_VIEW",
                "UI_LIST_VIEW",
                nullptr
        };
        return names;
    }

    inline const char *EnumNameNodeType(NodeType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesNodeType()[index];
    }

    enum Component {
        Component_NONE = 0,
        Component_Sprite = 1,
        Component_Label = 2,
        Component_Button = 3,
        Component_MIN = Component_NONE,
        Component_MAX = Component_Button
    };

    inline Component (&EnumValuesComponent())[4] {
            static Component values[] = {
                Component_NONE,
                        Component_Sprite,
                        Component_Label,
                        Component_Button
            };
            return values;
    }

    inline const char **EnumNamesComponent() {
        static const char *names[] = {
                "NONE",
                "Sprite",
                "Label",
                "Button",
                nullptr
        };
        return names;
    }

    inline const char *EnumNameComponent(Component e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesComponent()[index];
    }

    template<typename T> struct ComponentTraits {
        static const Component enum_value = Component_NONE;
    };

    template<> struct ComponentTraits<Sprite> {
        static const Component enum_value = Component_Sprite;
    };

    template<> struct ComponentTraits<Label> {
        static const Component enum_value = Component_Label;
    };

    template<> struct ComponentTraits<Button> {
        static const Component enum_value = Component_Button;
    };

    struct ComponentUnion {
        Component type;
        void *value;

        ComponentUnion() : type(Component_NONE), value(nullptr) {}
        ComponentUnion(ComponentUnion&& u) FLATBUFFERS_NOEXCEPT :
                type(Component_NONE), value(nullptr)
        { std::swap(type, u.type); std::swap(value, u.value); }
        ComponentUnion(const ComponentUnion &) FLATBUFFERS_NOEXCEPT;
        ComponentUnion &operator=(const ComponentUnion &u) FLATBUFFERS_NOEXCEPT
        { ComponentUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
        ComponentUnion &operator=(ComponentUnion &&u) FLATBUFFERS_NOEXCEPT
        { std::swap(type, u.type); std::swap(value, u.value); return *this; }
        ~ComponentUnion() { Reset(); }

        void Reset();

#ifndef FLATBUFFERS_CPP98_STL
        template <typename T>
        void Set(T&& val) {
            Reset();
            type = ComponentTraits<typename T::TableType>::enum_value;
            if (type != Component_NONE) {
                value = new T(std::forward<T>(val));
            }
        }
#endif  // FLATBUFFERS_CPP98_STL

        static void *UnPack(const void *obj, Component type, const flatbuffers::resolver_function_t *resolver);
        flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

        SpriteT *AsSprite() {
            return type == Component_Sprite ?
                   reinterpret_cast<SpriteT *>(value) : nullptr;
        }
        const SpriteT *AsSprite() const {
            return type == Component_Sprite ?
                   reinterpret_cast<const SpriteT *>(value) : nullptr;
        }
        LabelT *AsLabel() {
            return type == Component_Label ?
                   reinterpret_cast<LabelT *>(value) : nullptr;
        }
        const LabelT *AsLabel() const {
            return type == Component_Label ?
                   reinterpret_cast<const LabelT *>(value) : nullptr;
        }
        ButtonT *AsButton() {
            return type == Component_Button ?
                   reinterpret_cast<ButtonT *>(value) : nullptr;
        }
        const ButtonT *AsButton() const {
            return type == Component_Button ?
                   reinterpret_cast<const ButtonT *>(value) : nullptr;
        }
    };

    bool VerifyComponent(flatbuffers::Verifier &verifier, const void *obj, Component type);
    bool VerifyComponentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

    enum BodyType {
        BodyType_STATIC = 0,
        BodyType_DYNAMIC = 1,
        BodyType_KINEMATIC = 2,
        BodyType_MIN = BodyType_STATIC,
        BodyType_MAX = BodyType_KINEMATIC
    };

    inline BodyType (&EnumValuesBodyType())[3] {
            static BodyType values[] = {
                BodyType_STATIC,
                        BodyType_DYNAMIC,
                        BodyType_KINEMATIC
            };
            return values;
    }

    inline const char **EnumNamesBodyType() {
        static const char *names[] = {
                "STATIC",
                "DYNAMIC",
                "KINEMATIC",
                nullptr
        };
        return names;
    }

    inline const char *EnumNameBodyType(BodyType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesBodyType()[index];
    }

    enum FixtureType {
        FixtureType_POLYGON = 0,
        FixtureType_CIRCLE = 1,
        FixtureType_LINE = 2,
        FixtureType_MIN = FixtureType_POLYGON,
        FixtureType_MAX = FixtureType_LINE
    };

    inline FixtureType (&EnumValuesFixtureType())[3] {
            static FixtureType values[] = {
                FixtureType_POLYGON,
                        FixtureType_CIRCLE,
                        FixtureType_LINE
            };
            return values;
    }

    inline const char **EnumNamesFixtureType() {
        static const char *names[] = {
                "POLYGON",
                "CIRCLE",
                "LINE",
                nullptr
        };
        return names;
    }

    inline const char *EnumNameFixtureType(FixtureType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesFixtureType()[index];
    }

    enum JointType {
        JointType_REVOLUTE = 0,
        JointType_PRISMATIC = 1,
        JointType_MIN = JointType_REVOLUTE,
        JointType_MAX = JointType_PRISMATIC
    };

    inline JointType (&EnumValuesJointType())[2] {
            static JointType values[] = {
                JointType_REVOLUTE,
                        JointType_PRISMATIC
            };
            return values;
    }

    inline const char **EnumNamesJointType() {
        static const char *names[] = {
                "REVOLUTE",
                "PRISMATIC",
                nullptr
        };
        return names;
    }

    inline const char *EnumNameJointType(JointType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesJointType()[index];
    }

    MANUALLY_ALIGNED_STRUCT(1) Vec4b FLATBUFFERS_FINAL_CLASS {
    private:
        uint8_t a_;
        uint8_t r_;
        uint8_t g_;
        uint8_t b_;

    public:
        Vec4b() {
            memset(this, 0, sizeof(Vec4b));
        }
        Vec4b(uint8_t _a, uint8_t _r, uint8_t _g, uint8_t _b)
                : a_(flatbuffers::EndianScalar(_a)),
                  r_(flatbuffers::EndianScalar(_r)),
                  g_(flatbuffers::EndianScalar(_g)),
                  b_(flatbuffers::EndianScalar(_b)) {
        }
        uint8_t a() const {
            return flatbuffers::EndianScalar(a_);
        }
        uint8_t r() const {
            return flatbuffers::EndianScalar(r_);
        }
        uint8_t g() const {
            return flatbuffers::EndianScalar(g_);
        }
        uint8_t b() const {
            return flatbuffers::EndianScalar(b_);
        }
    };
    STRUCT_END(Vec4b, 4);

    MANUALLY_ALIGNED_STRUCT(4) Vec4f FLATBUFFERS_FINAL_CLASS {
    private:
        float a_;
        float r_;
        float g_;
        float b_;

    public:
        Vec4f() {
            memset(this, 0, sizeof(Vec4f));
        }
        Vec4f(float _a, float _r, float _g, float _b)
                : a_(flatbuffers::EndianScalar(_a)),
                  r_(flatbuffers::EndianScalar(_r)),
                  g_(flatbuffers::EndianScalar(_g)),
                  b_(flatbuffers::EndianScalar(_b)) {
        }
        float a() const {
            return flatbuffers::EndianScalar(a_);
        }
        float r() const {
            return flatbuffers::EndianScalar(r_);
        }
        float g() const {
            return flatbuffers::EndianScalar(g_);
        }
        float b() const {
            return flatbuffers::EndianScalar(b_);
        }
    };
    STRUCT_END(Vec4f, 16);

    MANUALLY_ALIGNED_STRUCT(4) Vec2f FLATBUFFERS_FINAL_CLASS {
    private:
        float x_;
        float y_;

    public:
        Vec2f() {
            memset(this, 0, sizeof(Vec2f));
        }
        Vec2f(float _x, float _y)
                : x_(flatbuffers::EndianScalar(_x)),
                  y_(flatbuffers::EndianScalar(_y)) {
        }
        float x() const {
            return flatbuffers::EndianScalar(x_);
        }
        float y() const {
            return flatbuffers::EndianScalar(y_);
        }
    };
    STRUCT_END(Vec2f, 8);

    MANUALLY_ALIGNED_STRUCT(4) Sizef FLATBUFFERS_FINAL_CLASS {
    private:
        float width_;
        float height_;

    public:
        Sizef() {
            memset(this, 0, sizeof(Sizef));
        }
        Sizef(float _width, float _height)
                : width_(flatbuffers::EndianScalar(_width)),
                  height_(flatbuffers::EndianScalar(_height)) {
        }
        float width() const {
            return flatbuffers::EndianScalar(width_);
        }
        float height() const {
            return flatbuffers::EndianScalar(height_);
        }
    };
    STRUCT_END(Sizef, 8);

    struct EditorRootT : public flatbuffers::NativeTable {
        typedef EditorRoot TableType;
        std::vector<std::string> textures;
        std::vector<std::unique_ptr<NodeTreeT>> nodes;
        EditorRootT() {
        }
    };

    struct EditorRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef EditorRootT NativeTableType;
        enum {
            VT_TEXTURES = 4,
            VT_NODES = 6
        };
        const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *textures() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TEXTURES);
        }
        const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *nodes() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *>(VT_NODES);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyOffset(verifier, VT_TEXTURES) &&
                   verifier.Verify(textures()) &&
                   verifier.VerifyVectorOfStrings(textures()) &&
                   VerifyOffset(verifier, VT_NODES) &&
                   verifier.Verify(nodes()) &&
                   verifier.VerifyVectorOfTables(nodes()) &&
                   verifier.EndTable();
        }
        EditorRootT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        void UnPackTo(EditorRootT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        static flatbuffers::Offset<EditorRoot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EditorRootT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
    };

    struct EditorRootBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> textures) {
            fbb_.AddOffset(EditorRoot::VT_TEXTURES, textures);
        }
        void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> nodes) {
            fbb_.AddOffset(EditorRoot::VT_NODES, nodes);
        }
        explicit EditorRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        EditorRootBuilder &operator=(const EditorRootBuilder &);
        flatbuffers::Offset<EditorRoot> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<EditorRoot>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<EditorRoot> CreateEditorRoot(
            flatbuffers::FlatBufferBuilder &_fbb,
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> textures = 0,
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> nodes = 0) {
        EditorRootBuilder builder_(_fbb);
        builder_.add_nodes(nodes);
        builder_.add_textures(textures);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<EditorRoot> CreateEditorRootDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            const std::vector<flatbuffers::Offset<flatbuffers::String>> *textures = nullptr,
            const std::vector<flatbuffers::Offset<NodeTree>> *nodes = nullptr) {
        return Editor::CreateEditorRoot(
                _fbb,
                textures ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*textures) : 0,
                nodes ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*nodes) : 0);
    }

    flatbuffers::Offset<EditorRoot> CreateEditorRoot(flatbuffers::FlatBufferBuilder &_fbb, const EditorRootT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

    struct NodeTreeT : public flatbuffers::NativeTable {
        typedef NodeTree TableType;
        std::string name;
        std::unique_ptr<Vec2f> position;
        std::unique_ptr<Vec2f> scale;
        std::unique_ptr<Sizef> size;
        int32_t rotation;
        std::unique_ptr<Vec2f> anchor;
        int32_t zOrder;
        uint8_t opacity;
        std::unique_ptr<Vec4f> color;
        std::vector<std::unique_ptr<NodeTreeT>> children;
        NodeType type;
        ComponentUnion component;
        bool enablePhysics;
        std::unique_ptr<BodyT> physics;
        NodeTreeT()
                : rotation(0),
                  zOrder(0),
                  opacity(0),
                  type(NodeType_BUTTON),
                  enablePhysics(false) {
        }
    };

    struct NodeTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef NodeTreeT NativeTableType;
        enum {
            VT_NAME = 4,
            VT_POSITION = 6,
            VT_SCALE = 8,
            VT_SIZE = 10,
            VT_ROTATION = 12,
            VT_ANCHOR = 14,
            VT_ZORDER = 16,
            VT_OPACITY = 18,
            VT_COLOR = 20,
            VT_CHILDREN = 22,
            VT_TYPE = 24,
            VT_COMPONENT_TYPE = 26,
            VT_COMPONENT = 28,
            VT_ENABLEPHYSICS = 30,
            VT_PHYSICS = 32
        };
        const flatbuffers::String *name() const {
            return GetPointer<const flatbuffers::String *>(VT_NAME);
        }
        const Vec2f *position() const {
            return GetStruct<const Vec2f *>(VT_POSITION);
        }
        const Vec2f *scale() const {
            return GetStruct<const Vec2f *>(VT_SCALE);
        }
        const Sizef *size() const {
            return GetStruct<const Sizef *>(VT_SIZE);
        }
        int32_t rotation() const {
            return GetField<int32_t>(VT_ROTATION, 0);
        }
        const Vec2f *anchor() const {
            return GetStruct<const Vec2f *>(VT_ANCHOR);
        }
        int32_t zOrder() const {
            return GetField<int32_t>(VT_ZORDER, 0);
        }
        uint8_t opacity() const {
            return GetField<uint8_t>(VT_OPACITY, 0);
        }
        const Vec4f *color() const {
            return GetStruct<const Vec4f *>(VT_COLOR);
        }
        const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *children() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *>(VT_CHILDREN);
        }
        NodeType type() const {
            return static_cast<NodeType>(GetField<int8_t>(VT_TYPE, 0));
        }
        Component component_type() const {
            return static_cast<Component>(GetField<uint8_t>(VT_COMPONENT_TYPE, 0));
        }
        const void *component() const {
            return GetPointer<const void *>(VT_COMPONENT);
        }
        template<typename T> const T *component_as() const;
        const Sprite *component_as_Sprite() const {
            return component_type() == Component_Sprite ? static_cast<const Sprite *>(component()) : nullptr;
        }
        const Label *component_as_Label() const {
            return component_type() == Component_Label ? static_cast<const Label *>(component()) : nullptr;
        }
        const Button *component_as_Button() const {
            return component_type() == Component_Button ? static_cast<const Button *>(component()) : nullptr;
        }
        bool enablePhysics() const {
            return GetField<uint8_t>(VT_ENABLEPHYSICS, 0) != 0;
        }
        const Body *physics() const {
            return GetPointer<const Body *>(VT_PHYSICS);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyOffset(verifier, VT_NAME) &&
                   verifier.Verify(name()) &&
                   VerifyField<Vec2f>(verifier, VT_POSITION) &&
                   VerifyField<Vec2f>(verifier, VT_SCALE) &&
                   VerifyField<Sizef>(verifier, VT_SIZE) &&
                   VerifyField<int32_t>(verifier, VT_ROTATION) &&
                   VerifyField<Vec2f>(verifier, VT_ANCHOR) &&
                   VerifyField<int32_t>(verifier, VT_ZORDER) &&
                   VerifyField<uint8_t>(verifier, VT_OPACITY) &&
                   VerifyField<Vec4f>(verifier, VT_COLOR) &&
                   VerifyOffset(verifier, VT_CHILDREN) &&
                   verifier.Verify(children()) &&
                   verifier.VerifyVectorOfTables(children()) &&
                   VerifyField<int8_t>(verifier, VT_TYPE) &&
                   VerifyField<uint8_t>(verifier, VT_COMPONENT_TYPE) &&
                   VerifyOffset(verifier, VT_COMPONENT) &&
                   VerifyComponent(verifier, component(), component_type()) &&
                   VerifyField<uint8_t>(verifier, VT_ENABLEPHYSICS) &&
                   VerifyOffset(verifier, VT_PHYSICS) &&
                   verifier.VerifyTable(physics()) &&
                   verifier.EndTable();
        }
        NodeTreeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        void UnPackTo(NodeTreeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        static flatbuffers::Offset<NodeTree> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NodeTreeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
    };

    template<> inline const Sprite *NodeTree::component_as<Sprite>() const {
        return component_as_Sprite();
    }

    template<> inline const Label *NodeTree::component_as<Label>() const {
        return component_as_Label();
    }

    template<> inline const Button *NodeTree::component_as<Button>() const {
        return component_as_Button();
    }

    struct NodeTreeBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_name(flatbuffers::Offset<flatbuffers::String> name) {
            fbb_.AddOffset(NodeTree::VT_NAME, name);
        }
        void add_position(const Vec2f *position) {
            fbb_.AddStruct(NodeTree::VT_POSITION, position);
        }
        void add_scale(const Vec2f *scale) {
            fbb_.AddStruct(NodeTree::VT_SCALE, scale);
        }
        void add_size(const Sizef *size) {
            fbb_.AddStruct(NodeTree::VT_SIZE, size);
        }
        void add_rotation(int32_t rotation) {
            fbb_.AddElement<int32_t>(NodeTree::VT_ROTATION, rotation, 0);
        }
        void add_anchor(const Vec2f *anchor) {
            fbb_.AddStruct(NodeTree::VT_ANCHOR, anchor);
        }
        void add_zOrder(int32_t zOrder) {
            fbb_.AddElement<int32_t>(NodeTree::VT_ZORDER, zOrder, 0);
        }
        void add_opacity(uint8_t opacity) {
            fbb_.AddElement<uint8_t>(NodeTree::VT_OPACITY, opacity, 0);
        }
        void add_color(const Vec4f *color) {
            fbb_.AddStruct(NodeTree::VT_COLOR, color);
        }
        void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children) {
            fbb_.AddOffset(NodeTree::VT_CHILDREN, children);
        }
        void add_type(NodeType type) {
            fbb_.AddElement<int8_t>(NodeTree::VT_TYPE, static_cast<int8_t>(type), 0);
        }
        void add_component_type(Component component_type) {
            fbb_.AddElement<uint8_t>(NodeTree::VT_COMPONENT_TYPE, static_cast<uint8_t>(component_type), 0);
        }
        void add_component(flatbuffers::Offset<void> component) {
            fbb_.AddOffset(NodeTree::VT_COMPONENT, component);
        }
        void add_enablePhysics(bool enablePhysics) {
            fbb_.AddElement<uint8_t>(NodeTree::VT_ENABLEPHYSICS, static_cast<uint8_t>(enablePhysics), 0);
        }
        void add_physics(flatbuffers::Offset<Body> physics) {
            fbb_.AddOffset(NodeTree::VT_PHYSICS, physics);
        }
        explicit NodeTreeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        NodeTreeBuilder &operator=(const NodeTreeBuilder &);
        flatbuffers::Offset<NodeTree> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<NodeTree>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<NodeTree> CreateNodeTree(
            flatbuffers::FlatBufferBuilder &_fbb,
            flatbuffers::Offset<flatbuffers::String> name = 0,
            const Vec2f *position = 0,
            const Vec2f *scale = 0,
            const Sizef *size = 0,
            int32_t rotation = 0,
            const Vec2f *anchor = 0,
            int32_t zOrder = 0,
            uint8_t opacity = 0,
            const Vec4f *color = 0,
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children = 0,
            NodeType type = NodeType_BUTTON,
            Component component_type = Component_NONE,
            flatbuffers::Offset<void> component = 0,
            bool enablePhysics = false,
            flatbuffers::Offset<Body> physics = 0) {
        NodeTreeBuilder builder_(_fbb);
        builder_.add_physics(physics);
        builder_.add_component(component);
        builder_.add_children(children);
        builder_.add_color(color);
        builder_.add_zOrder(zOrder);
        builder_.add_anchor(anchor);
        builder_.add_rotation(rotation);
        builder_.add_size(size);
        builder_.add_scale(scale);
        builder_.add_position(position);
        builder_.add_name(name);
        builder_.add_enablePhysics(enablePhysics);
        builder_.add_component_type(component_type);
        builder_.add_type(type);
        builder_.add_opacity(opacity);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<NodeTree> CreateNodeTreeDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            const char *name = nullptr,
            const Vec2f *position = 0,
            const Vec2f *scale = 0,
            const Sizef *size = 0,
            int32_t rotation = 0,
            const Vec2f *anchor = 0,
            int32_t zOrder = 0,
            uint8_t opacity = 0,
            const Vec4f *color = 0,
            const std::vector<flatbuffers::Offset<NodeTree>> *children = nullptr,
            NodeType type = NodeType_BUTTON,
            Component component_type = Component_NONE,
            flatbuffers::Offset<void> component = 0,
            bool enablePhysics = false,
            flatbuffers::Offset<Body> physics = 0) {
        return Editor::CreateNodeTree(
                _fbb,
                name ? _fbb.CreateString(name) : 0,
                position,
                scale,
                size,
                rotation,
                anchor,
                zOrder,
                opacity,
                color,
                children ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*children) : 0,
                type,
                component_type,
                component,
                enablePhysics,
                physics);
    }

    flatbuffers::Offset<NodeTree> CreateNodeTree(flatbuffers::FlatBufferBuilder &_fbb, const NodeTreeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

    struct SpriteT : public flatbuffers::NativeTable {
        typedef Sprite TableType;
        std::string frameName;
        SpriteT() {
        }
    };

    struct Sprite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef SpriteT NativeTableType;
        enum {
            VT_FRAMENAME = 4
        };
        const flatbuffers::String *frameName() const {
            return GetPointer<const flatbuffers::String *>(VT_FRAMENAME);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyOffset(verifier, VT_FRAMENAME) &&
                   verifier.Verify(frameName()) &&
                   verifier.EndTable();
        }
        SpriteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        void UnPackTo(SpriteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        static flatbuffers::Offset<Sprite> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpriteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
    };

    struct SpriteBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_frameName(flatbuffers::Offset<flatbuffers::String> frameName) {
            fbb_.AddOffset(Sprite::VT_FRAMENAME, frameName);
        }
        explicit SpriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        SpriteBuilder &operator=(const SpriteBuilder &);
        flatbuffers::Offset<Sprite> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Sprite>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Sprite> CreateSprite(
            flatbuffers::FlatBufferBuilder &_fbb,
            flatbuffers::Offset<flatbuffers::String> frameName = 0) {
        SpriteBuilder builder_(_fbb);
        builder_.add_frameName(frameName);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Sprite> CreateSpriteDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            const char *frameName = nullptr) {
        return Editor::CreateSprite(
                _fbb,
                frameName ? _fbb.CreateString(frameName) : 0);
    }

    flatbuffers::Offset<Sprite> CreateSprite(flatbuffers::FlatBufferBuilder &_fbb, const SpriteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

    struct LabelT : public flatbuffers::NativeTable {
        typedef Label TableType;
        std::string font;
        std::string text;
        LabelT() {
        }
    };

    struct Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef LabelT NativeTableType;
        enum {
            VT_FONT = 4,
            VT_TEXT = 6
        };
        const flatbuffers::String *font() const {
            return GetPointer<const flatbuffers::String *>(VT_FONT);
        }
        const flatbuffers::String *text() const {
            return GetPointer<const flatbuffers::String *>(VT_TEXT);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyOffset(verifier, VT_FONT) &&
                   verifier.Verify(font()) &&
                   VerifyOffset(verifier, VT_TEXT) &&
                   verifier.Verify(text()) &&
                   verifier.EndTable();
        }
        LabelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        void UnPackTo(LabelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        static flatbuffers::Offset<Label> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LabelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
    };

    struct LabelBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_font(flatbuffers::Offset<flatbuffers::String> font) {
            fbb_.AddOffset(Label::VT_FONT, font);
        }
        void add_text(flatbuffers::Offset<flatbuffers::String> text) {
            fbb_.AddOffset(Label::VT_TEXT, text);
        }
        explicit LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        LabelBuilder &operator=(const LabelBuilder &);
        flatbuffers::Offset<Label> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Label>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Label> CreateLabel(
            flatbuffers::FlatBufferBuilder &_fbb,
            flatbuffers::Offset<flatbuffers::String> font = 0,
            flatbuffers::Offset<flatbuffers::String> text = 0) {
        LabelBuilder builder_(_fbb);
        builder_.add_text(text);
        builder_.add_font(font);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Label> CreateLabelDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            const char *font = nullptr,
            const char *text = nullptr) {
        return Editor::CreateLabel(
                _fbb,
                font ? _fbb.CreateString(font) : 0,
                text ? _fbb.CreateString(text) : 0);
    }

    flatbuffers::Offset<Label> CreateLabel(flatbuffers::FlatBufferBuilder &_fbb, const LabelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

    struct ButtonT : public flatbuffers::NativeTable {
        typedef Button TableType;
        std::string text;
        std::string textureNormal;
        std::string textureSelected;
        std::string textureDisabled;
        ButtonT() {
        }
    };

    struct Button FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef ButtonT NativeTableType;
        enum {
            VT_TEXT = 4,
            VT_TEXTURENORMAL = 6,
            VT_TEXTURESELECTED = 8,
            VT_TEXTUREDISABLED = 10
        };
        const flatbuffers::String *text() const {
            return GetPointer<const flatbuffers::String *>(VT_TEXT);
        }
        const flatbuffers::String *textureNormal() const {
            return GetPointer<const flatbuffers::String *>(VT_TEXTURENORMAL);
        }
        const flatbuffers::String *textureSelected() const {
            return GetPointer<const flatbuffers::String *>(VT_TEXTURESELECTED);
        }
        const flatbuffers::String *textureDisabled() const {
            return GetPointer<const flatbuffers::String *>(VT_TEXTUREDISABLED);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyOffset(verifier, VT_TEXT) &&
                   verifier.Verify(text()) &&
                   VerifyOffset(verifier, VT_TEXTURENORMAL) &&
                   verifier.Verify(textureNormal()) &&
                   VerifyOffset(verifier, VT_TEXTURESELECTED) &&
                   verifier.Verify(textureSelected()) &&
                   VerifyOffset(verifier, VT_TEXTUREDISABLED) &&
                   verifier.Verify(textureDisabled()) &&
                   verifier.EndTable();
        }
        ButtonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        void UnPackTo(ButtonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        static flatbuffers::Offset<Button> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ButtonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
    };

    struct ButtonBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_text(flatbuffers::Offset<flatbuffers::String> text) {
            fbb_.AddOffset(Button::VT_TEXT, text);
        }
        void add_textureNormal(flatbuffers::Offset<flatbuffers::String> textureNormal) {
            fbb_.AddOffset(Button::VT_TEXTURENORMAL, textureNormal);
        }
        void add_textureSelected(flatbuffers::Offset<flatbuffers::String> textureSelected) {
            fbb_.AddOffset(Button::VT_TEXTURESELECTED, textureSelected);
        }
        void add_textureDisabled(flatbuffers::Offset<flatbuffers::String> textureDisabled) {
            fbb_.AddOffset(Button::VT_TEXTUREDISABLED, textureDisabled);
        }
        explicit ButtonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        ButtonBuilder &operator=(const ButtonBuilder &);
        flatbuffers::Offset<Button> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Button>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Button> CreateButton(
            flatbuffers::FlatBufferBuilder &_fbb,
            flatbuffers::Offset<flatbuffers::String> text = 0,
            flatbuffers::Offset<flatbuffers::String> textureNormal = 0,
            flatbuffers::Offset<flatbuffers::String> textureSelected = 0,
            flatbuffers::Offset<flatbuffers::String> textureDisabled = 0) {
        ButtonBuilder builder_(_fbb);
        builder_.add_textureDisabled(textureDisabled);
        builder_.add_textureSelected(textureSelected);
        builder_.add_textureNormal(textureNormal);
        builder_.add_text(text);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Button> CreateButtonDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            const char *text = nullptr,
            const char *textureNormal = nullptr,
            const char *textureSelected = nullptr,
            const char *textureDisabled = nullptr) {
        return Editor::CreateButton(
                _fbb,
                text ? _fbb.CreateString(text) : 0,
                textureNormal ? _fbb.CreateString(textureNormal) : 0,
                textureSelected ? _fbb.CreateString(textureSelected) : 0,
                textureDisabled ? _fbb.CreateString(textureDisabled) : 0);
    }

    flatbuffers::Offset<Button> CreateButton(flatbuffers::FlatBufferBuilder &_fbb, const ButtonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

    struct BodyT : public flatbuffers::NativeTable {
        typedef Body TableType;
        int32_t id;
        std::unique_ptr<Vec2f> pos;
        BodyType type;
        std::vector<std::unique_ptr<FixtureT>> fixtures;
        BodyT()
                : id(0),
                  type(BodyType_STATIC) {
        }
    };

    struct Body FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef BodyT NativeTableType;
        enum {
            VT_ID = 4,
            VT_POS = 6,
            VT_TYPE = 8,
            VT_FIXTURES = 10
        };
        int32_t id() const {
            return GetField<int32_t>(VT_ID, 0);
        }
        const Vec2f *pos() const {
            return GetStruct<const Vec2f *>(VT_POS);
        }
        BodyType type() const {
            return static_cast<BodyType>(GetField<int8_t>(VT_TYPE, 0));
        }
        const flatbuffers::Vector<flatbuffers::Offset<Fixture>> *fixtures() const {
            return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fixture>> *>(VT_FIXTURES);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyField<int32_t>(verifier, VT_ID) &&
                   VerifyField<Vec2f>(verifier, VT_POS) &&
                   VerifyField<int8_t>(verifier, VT_TYPE) &&
                   VerifyOffset(verifier, VT_FIXTURES) &&
                   verifier.Verify(fixtures()) &&
                   verifier.VerifyVectorOfTables(fixtures()) &&
                   verifier.EndTable();
        }
        BodyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        void UnPackTo(BodyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        static flatbuffers::Offset<Body> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BodyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
    };

    struct BodyBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(int32_t id) {
            fbb_.AddElement<int32_t>(Body::VT_ID, id, 0);
        }
        void add_pos(const Vec2f *pos) {
            fbb_.AddStruct(Body::VT_POS, pos);
        }
        void add_type(BodyType type) {
            fbb_.AddElement<int8_t>(Body::VT_TYPE, static_cast<int8_t>(type), 0);
        }
        void add_fixtures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fixture>>> fixtures) {
            fbb_.AddOffset(Body::VT_FIXTURES, fixtures);
        }
        explicit BodyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        BodyBuilder &operator=(const BodyBuilder &);
        flatbuffers::Offset<Body> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Body>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Body> CreateBody(
            flatbuffers::FlatBufferBuilder &_fbb,
            int32_t id = 0,
            const Vec2f *pos = 0,
            BodyType type = BodyType_STATIC,
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fixture>>> fixtures = 0) {
        BodyBuilder builder_(_fbb);
        builder_.add_fixtures(fixtures);
        builder_.add_pos(pos);
        builder_.add_id(id);
        builder_.add_type(type);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Body> CreateBodyDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            int32_t id = 0,
            const Vec2f *pos = 0,
            BodyType type = BodyType_STATIC,
            const std::vector<flatbuffers::Offset<Fixture>> *fixtures = nullptr) {
        return Editor::CreateBody(
                _fbb,
                id,
                pos,
                type,
                fixtures ? _fbb.CreateVector<flatbuffers::Offset<Fixture>>(*fixtures) : 0);
    }

    flatbuffers::Offset<Body> CreateBody(flatbuffers::FlatBufferBuilder &_fbb, const BodyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

    struct FixtureT : public flatbuffers::NativeTable {
        typedef Fixture TableType;
        std::string name;
        FixtureType type;
        float density;
        float friction;
        float restitution;
        std::vector<Vec2f> points;
        FixtureT()
                : type(FixtureType_POLYGON),
                  density(0.0f),
                  friction(0.0f),
                  restitution(0.0f) {
        }
    };

    struct Fixture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef FixtureT NativeTableType;
        enum {
            VT_NAME = 4,
            VT_TYPE = 6,
            VT_DENSITY = 8,
            VT_FRICTION = 10,
            VT_RESTITUTION = 12,
            VT_POINTS = 14
        };
        const flatbuffers::String *name() const {
            return GetPointer<const flatbuffers::String *>(VT_NAME);
        }
        FixtureType type() const {
            return static_cast<FixtureType>(GetField<int8_t>(VT_TYPE, 0));
        }
        float density() const {
            return GetField<float>(VT_DENSITY, 0.0f);
        }
        float friction() const {
            return GetField<float>(VT_FRICTION, 0.0f);
        }
        float restitution() const {
            return GetField<float>(VT_RESTITUTION, 0.0f);
        }
        const flatbuffers::Vector<const Vec2f *> *points() const {
            return GetPointer<const flatbuffers::Vector<const Vec2f *> *>(VT_POINTS);
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyOffset(verifier, VT_NAME) &&
                   verifier.Verify(name()) &&
                   VerifyField<int8_t>(verifier, VT_TYPE) &&
                   VerifyField<float>(verifier, VT_DENSITY) &&
                   VerifyField<float>(verifier, VT_FRICTION) &&
                   VerifyField<float>(verifier, VT_RESTITUTION) &&
                   VerifyOffset(verifier, VT_POINTS) &&
                   verifier.Verify(points()) &&
                   verifier.EndTable();
        }
        FixtureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        void UnPackTo(FixtureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        static flatbuffers::Offset<Fixture> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FixtureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
    };

    struct FixtureBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_name(flatbuffers::Offset<flatbuffers::String> name) {
            fbb_.AddOffset(Fixture::VT_NAME, name);
        }
        void add_type(FixtureType type) {
            fbb_.AddElement<int8_t>(Fixture::VT_TYPE, static_cast<int8_t>(type), 0);
        }
        void add_density(float density) {
            fbb_.AddElement<float>(Fixture::VT_DENSITY, density, 0.0f);
        }
        void add_friction(float friction) {
            fbb_.AddElement<float>(Fixture::VT_FRICTION, friction, 0.0f);
        }
        void add_restitution(float restitution) {
            fbb_.AddElement<float>(Fixture::VT_RESTITUTION, restitution, 0.0f);
        }
        void add_points(flatbuffers::Offset<flatbuffers::Vector<const Vec2f *>> points) {
            fbb_.AddOffset(Fixture::VT_POINTS, points);
        }
        explicit FixtureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        FixtureBuilder &operator=(const FixtureBuilder &);
        flatbuffers::Offset<Fixture> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Fixture>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Fixture> CreateFixture(
            flatbuffers::FlatBufferBuilder &_fbb,
            flatbuffers::Offset<flatbuffers::String> name = 0,
            FixtureType type = FixtureType_POLYGON,
            float density = 0.0f,
            float friction = 0.0f,
            float restitution = 0.0f,
            flatbuffers::Offset<flatbuffers::Vector<const Vec2f *>> points = 0) {
        FixtureBuilder builder_(_fbb);
        builder_.add_points(points);
        builder_.add_restitution(restitution);
        builder_.add_friction(friction);
        builder_.add_density(density);
        builder_.add_name(name);
        builder_.add_type(type);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Fixture> CreateFixtureDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            const char *name = nullptr,
            FixtureType type = FixtureType_POLYGON,
            float density = 0.0f,
            float friction = 0.0f,
            float restitution = 0.0f,
            const std::vector<const Vec2f *> *points = nullptr) {
        return Editor::CreateFixture(
                _fbb,
                name ? _fbb.CreateString(name) : 0,
                type,
                density,
                friction,
                restitution,
                points ? _fbb.CreateVector<const Vec2f *>(*points) : 0);
    }

    flatbuffers::Offset<Fixture> CreateFixture(flatbuffers::FlatBufferBuilder &_fbb, const FixtureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

    struct JointT : public flatbuffers::NativeTable {
        typedef Joint TableType;
        int32_t bodyA;
        int32_t bodyB;
        std::unique_ptr<Vec2f> posA;
        std::unique_ptr<Vec2f> posB;
        JointType type;
        JointT()
                : bodyA(0),
                  bodyB(0),
                  type(JointType_REVOLUTE) {
        }
    };

    struct Joint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        typedef JointT NativeTableType;
        enum {
            VT_BODYA = 4,
            VT_BODYB = 6,
            VT_POSA = 8,
            VT_POSB = 10,
            VT_TYPE = 12
        };
        int32_t bodyA() const {
            return GetField<int32_t>(VT_BODYA, 0);
        }
        int32_t bodyB() const {
            return GetField<int32_t>(VT_BODYB, 0);
        }
        const Vec2f *posA() const {
            return GetStruct<const Vec2f *>(VT_POSA);
        }
        const Vec2f *posB() const {
            return GetStruct<const Vec2f *>(VT_POSB);
        }
        JointType type() const {
            return static_cast<JointType>(GetField<int8_t>(VT_TYPE, 0));
        }
        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyField<int32_t>(verifier, VT_BODYA) &&
                   VerifyField<int32_t>(verifier, VT_BODYB) &&
                   VerifyField<Vec2f>(verifier, VT_POSA) &&
                   VerifyField<Vec2f>(verifier, VT_POSB) &&
                   VerifyField<int8_t>(verifier, VT_TYPE) &&
                   verifier.EndTable();
        }
        JointT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        void UnPackTo(JointT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
        static flatbuffers::Offset<Joint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JointT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
    };

    struct JointBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_bodyA(int32_t bodyA) {
            fbb_.AddElement<int32_t>(Joint::VT_BODYA, bodyA, 0);
        }
        void add_bodyB(int32_t bodyB) {
            fbb_.AddElement<int32_t>(Joint::VT_BODYB, bodyB, 0);
        }
        void add_posA(const Vec2f *posA) {
            fbb_.AddStruct(Joint::VT_POSA, posA);
        }
        void add_posB(const Vec2f *posB) {
            fbb_.AddStruct(Joint::VT_POSB, posB);
        }
        void add_type(JointType type) {
            fbb_.AddElement<int8_t>(Joint::VT_TYPE, static_cast<int8_t>(type), 0);
        }
        explicit JointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }
        JointBuilder &operator=(const JointBuilder &);
        flatbuffers::Offset<Joint> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Joint>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Joint> CreateJoint(
            flatbuffers::FlatBufferBuilder &_fbb,
            int32_t bodyA = 0,
            int32_t bodyB = 0,
            const Vec2f *posA = 0,
            const Vec2f *posB = 0,
            JointType type = JointType_REVOLUTE) {
        JointBuilder builder_(_fbb);
        builder_.add_posB(posB);
        builder_.add_posA(posA);
        builder_.add_bodyB(bodyB);
        builder_.add_bodyA(bodyA);
        builder_.add_type(type);
        return builder_.Finish();
    }

    flatbuffers::Offset<Joint> CreateJoint(flatbuffers::FlatBufferBuilder &_fbb, const JointT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

    inline EditorRootT *EditorRoot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
        auto _o = new EditorRootT();
        UnPackTo(_o, _resolver);
        return _o;
    }

    inline void EditorRoot::UnPackTo(EditorRootT *_o, const flatbuffers::resolver_function_t *_resolver) const {
        (void)_o;
        (void)_resolver;
        { auto _e = textures(); if (_e) { _o->textures.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->textures[_i] = _e->Get(_i)->str(); } } };
        { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nodes[_i] = std::unique_ptr<NodeTreeT>(_e->Get(_i)->UnPack(_resolver)); } } };
    }

    inline flatbuffers::Offset<EditorRoot> EditorRoot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EditorRootT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
        return CreateEditorRoot(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<EditorRoot> CreateEditorRoot(flatbuffers::FlatBufferBuilder &_fbb, const EditorRootT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EditorRootT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
        auto _textures = _o->textures.size() ? _fbb.CreateVectorOfStrings(_o->textures) : 0;
        auto _nodes = _o->nodes.size() ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateNodeTree(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
        return Editor::CreateEditorRoot(
                _fbb,
                _textures,
                _nodes);
    }

    inline NodeTreeT *NodeTree::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
        auto _o = new NodeTreeT();
        UnPackTo(_o, _resolver);
        return _o;
    }

    inline void NodeTree::UnPackTo(NodeTreeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
        (void)_o;
        (void)_resolver;
        { auto _e = name(); if (_e) _o->name = _e->str(); };
        { auto _e = position(); if (_e) _o->position = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
        { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
        { auto _e = size(); if (_e) _o->size = std::unique_ptr<Sizef>(new Sizef(*_e)); };
        { auto _e = rotation(); _o->rotation = _e; };
        { auto _e = anchor(); if (_e) _o->anchor = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
        { auto _e = zOrder(); _o->zOrder = _e; };
        { auto _e = opacity(); _o->opacity = _e; };
        { auto _e = color(); if (_e) _o->color = std::unique_ptr<Vec4f>(new Vec4f(*_e)); };
        { auto _e = children(); if (_e) { _o->children.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->children[_i] = std::unique_ptr<NodeTreeT>(_e->Get(_i)->UnPack(_resolver)); } } };
        { auto _e = type(); _o->type = _e; };
        { auto _e = component_type(); _o->component.type = _e; };
        { auto _e = component(); if (_e) _o->component.value = ComponentUnion::UnPack(_e, component_type(), _resolver); };
        { auto _e = enablePhysics(); _o->enablePhysics = _e; };
        { auto _e = physics(); if (_e) _o->physics = std::unique_ptr<BodyT>(_e->UnPack(_resolver)); };
    }

    inline flatbuffers::Offset<NodeTree> NodeTree::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NodeTreeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
        return CreateNodeTree(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<NodeTree> CreateNodeTree(flatbuffers::FlatBufferBuilder &_fbb, const NodeTreeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NodeTreeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
        auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
        auto _position = _o->position ? _o->position.get() : 0;
        auto _scale = _o->scale ? _o->scale.get() : 0;
        auto _size = _o->size ? _o->size.get() : 0;
        auto _rotation = _o->rotation;
        auto _anchor = _o->anchor ? _o->anchor.get() : 0;
        auto _zOrder = _o->zOrder;
        auto _opacity = _o->opacity;
        auto _color = _o->color ? _o->color.get() : 0;
        auto _children = _o->children.size() ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>> (_o->children.size(), [](size_t i, _VectorArgs *__va) { return CreateNodeTree(*__va->__fbb, __va->__o->children[i].get(), __va->__rehasher); }, &_va ) : 0;
        auto _type = _o->type;
        auto _component_type = _o->component.type;
        auto _component = _o->component.Pack(_fbb);
        auto _enablePhysics = _o->enablePhysics;
        auto _physics = _o->physics ? CreateBody(_fbb, _o->physics.get(), _rehasher) : 0;
        return Editor::CreateNodeTree(
                _fbb,
                _name,
                _position,
                _scale,
                _size,
                _rotation,
                _anchor,
                _zOrder,
                _opacity,
                _color,
                _children,
                _type,
                _component_type,
                _component,
                _enablePhysics,
                _physics);
    }

    inline SpriteT *Sprite::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
        auto _o = new SpriteT();
        UnPackTo(_o, _resolver);
        return _o;
    }

    inline void Sprite::UnPackTo(SpriteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
        (void)_o;
        (void)_resolver;
        { auto _e = frameName(); if (_e) _o->frameName = _e->str(); };
    }

    inline flatbuffers::Offset<Sprite> Sprite::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpriteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
        return CreateSprite(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<Sprite> CreateSprite(flatbuffers::FlatBufferBuilder &_fbb, const SpriteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpriteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
        auto _frameName = _o->frameName.empty() ? 0 : _fbb.CreateString(_o->frameName);
        return Editor::CreateSprite(
                _fbb,
                _frameName);
    }

    inline LabelT *Label::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
        auto _o = new LabelT();
        UnPackTo(_o, _resolver);
        return _o;
    }

    inline void Label::UnPackTo(LabelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
        (void)_o;
        (void)_resolver;
        { auto _e = font(); if (_e) _o->font = _e->str(); };
        { auto _e = text(); if (_e) _o->text = _e->str(); };
    }

    inline flatbuffers::Offset<Label> Label::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LabelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
        return CreateLabel(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<Label> CreateLabel(flatbuffers::FlatBufferBuilder &_fbb, const LabelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LabelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
        auto _font = _o->font.empty() ? 0 : _fbb.CreateString(_o->font);
        auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
        return Editor::CreateLabel(
                _fbb,
                _font,
                _text);
    }

    inline ButtonT *Button::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
        auto _o = new ButtonT();
        UnPackTo(_o, _resolver);
        return _o;
    }

    inline void Button::UnPackTo(ButtonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
        (void)_o;
        (void)_resolver;
        { auto _e = text(); if (_e) _o->text = _e->str(); };
        { auto _e = textureNormal(); if (_e) _o->textureNormal = _e->str(); };
        { auto _e = textureSelected(); if (_e) _o->textureSelected = _e->str(); };
        { auto _e = textureDisabled(); if (_e) _o->textureDisabled = _e->str(); };
    }

    inline flatbuffers::Offset<Button> Button::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ButtonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
        return CreateButton(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<Button> CreateButton(flatbuffers::FlatBufferBuilder &_fbb, const ButtonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ButtonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
        auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
        auto _textureNormal = _o->textureNormal.empty() ? 0 : _fbb.CreateString(_o->textureNormal);
        auto _textureSelected = _o->textureSelected.empty() ? 0 : _fbb.CreateString(_o->textureSelected);
        auto _textureDisabled = _o->textureDisabled.empty() ? 0 : _fbb.CreateString(_o->textureDisabled);
        return Editor::CreateButton(
                _fbb,
                _text,
                _textureNormal,
                _textureSelected,
                _textureDisabled);
    }

    inline BodyT *Body::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
        auto _o = new BodyT();
        UnPackTo(_o, _resolver);
        return _o;
    }

    inline void Body::UnPackTo(BodyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
        (void)_o;
        (void)_resolver;
        { auto _e = id(); _o->id = _e; };
        { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
        { auto _e = type(); _o->type = _e; };
        { auto _e = fixtures(); if (_e) { _o->fixtures.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fixtures[_i] = std::unique_ptr<FixtureT>(_e->Get(_i)->UnPack(_resolver)); } } };
    }

    inline flatbuffers::Offset<Body> Body::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BodyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
        return CreateBody(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<Body> CreateBody(flatbuffers::FlatBufferBuilder &_fbb, const BodyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BodyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
        auto _id = _o->id;
        auto _pos = _o->pos ? _o->pos.get() : 0;
        auto _type = _o->type;
        auto _fixtures = _o->fixtures.size() ? _fbb.CreateVector<flatbuffers::Offset<Fixture>> (_o->fixtures.size(), [](size_t i, _VectorArgs *__va) { return CreateFixture(*__va->__fbb, __va->__o->fixtures[i].get(), __va->__rehasher); }, &_va ) : 0;
        return Editor::CreateBody(
                _fbb,
                _id,
                _pos,
                _type,
                _fixtures);
    }

    inline FixtureT *Fixture::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
        auto _o = new FixtureT();
        UnPackTo(_o, _resolver);
        return _o;
    }

    inline void Fixture::UnPackTo(FixtureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
        (void)_o;
        (void)_resolver;
        { auto _e = name(); if (_e) _o->name = _e->str(); };
        { auto _e = type(); _o->type = _e; };
        { auto _e = density(); _o->density = _e; };
        { auto _e = friction(); _o->friction = _e; };
        { auto _e = restitution(); _o->restitution = _e; };
        { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = *_e->Get(_i); } } };
    }

    inline flatbuffers::Offset<Fixture> Fixture::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FixtureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
        return CreateFixture(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<Fixture> CreateFixture(flatbuffers::FlatBufferBuilder &_fbb, const FixtureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FixtureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
        auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
        auto _type = _o->type;
        auto _density = _o->density;
        auto _friction = _o->friction;
        auto _restitution = _o->restitution;
        auto _points = _o->points.size() ? _fbb.CreateVectorOfStructs(_o->points) : 0;
        return Editor::CreateFixture(
                _fbb,
                _name,
                _type,
                _density,
                _friction,
                _restitution,
                _points);
    }

    inline JointT *Joint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
        auto _o = new JointT();
        UnPackTo(_o, _resolver);
        return _o;
    }

    inline void Joint::UnPackTo(JointT *_o, const flatbuffers::resolver_function_t *_resolver) const {
        (void)_o;
        (void)_resolver;
        { auto _e = bodyA(); _o->bodyA = _e; };
        { auto _e = bodyB(); _o->bodyB = _e; };
        { auto _e = posA(); if (_e) _o->posA = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
        { auto _e = posB(); if (_e) _o->posB = std::unique_ptr<Vec2f>(new Vec2f(*_e)); };
        { auto _e = type(); _o->type = _e; };
    }

    inline flatbuffers::Offset<Joint> Joint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JointT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
        return CreateJoint(_fbb, _o, _rehasher);
    }

    inline flatbuffers::Offset<Joint> CreateJoint(flatbuffers::FlatBufferBuilder &_fbb, const JointT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
        (void)_rehasher;
        (void)_o;
        struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const JointT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
        auto _bodyA = _o->bodyA;
        auto _bodyB = _o->bodyB;
        auto _posA = _o->posA ? _o->posA.get() : 0;
        auto _posB = _o->posB ? _o->posB.get() : 0;
        auto _type = _o->type;
        return Editor::CreateJoint(
                _fbb,
                _bodyA,
                _bodyB,
                _posA,
                _posB,
                _type);
    }

    inline bool VerifyComponent(flatbuffers::Verifier &verifier, const void *obj, Component type) {
        switch (type) {
            case Component_NONE: {
                return true;
            }
            case Component_Sprite: {
                auto ptr = reinterpret_cast<const Sprite *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Component_Label: {
                auto ptr = reinterpret_cast<const Label *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case Component_Button: {
                auto ptr = reinterpret_cast<const Button *>(obj);
                return verifier.VerifyTable(ptr);
            }
            default: return false;
        }
    }

    inline bool VerifyComponentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
        if (values->size() != types->size()) return false;
        for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
            if (!VerifyComponent(
                    verifier,  values->Get(i), types->GetEnum<Component>(i))) {
                return false;
            }
        }
        return true;
    }

    inline void *ComponentUnion::UnPack(const void *obj, Component type, const flatbuffers::resolver_function_t *resolver) {
        switch (type) {
            case Component_Sprite: {
                auto ptr = reinterpret_cast<const Sprite *>(obj);
                return ptr->UnPack(resolver);
            }
            case Component_Label: {
                auto ptr = reinterpret_cast<const Label *>(obj);
                return ptr->UnPack(resolver);
            }
            case Component_Button: {
                auto ptr = reinterpret_cast<const Button *>(obj);
                return ptr->UnPack(resolver);
            }
            default: return nullptr;
        }
    }

    inline flatbuffers::Offset<void> ComponentUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
        switch (type) {
            case Component_Sprite: {
                auto ptr = reinterpret_cast<const SpriteT *>(value);
                return CreateSprite(_fbb, ptr, _rehasher).Union();
            }
            case Component_Label: {
                auto ptr = reinterpret_cast<const LabelT *>(value);
                return CreateLabel(_fbb, ptr, _rehasher).Union();
            }
            case Component_Button: {
                auto ptr = reinterpret_cast<const ButtonT *>(value);
                return CreateButton(_fbb, ptr, _rehasher).Union();
            }
            default: return 0;
        }
    }

    inline ComponentUnion::ComponentUnion(const ComponentUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
        switch (type) {
            case Component_Sprite: {
                value = new SpriteT(*reinterpret_cast<SpriteT *>(u.value));
                break;
            }
            case Component_Label: {
                value = new LabelT(*reinterpret_cast<LabelT *>(u.value));
                break;
            }
            case Component_Button: {
                value = new ButtonT(*reinterpret_cast<ButtonT *>(u.value));
                break;
            }
            default:
                break;
        }
    }

    inline void ComponentUnion::Reset() {
        switch (type) {
            case Component_Sprite: {
                auto ptr = reinterpret_cast<SpriteT *>(value);
                delete ptr;
                break;
            }
            case Component_Label: {
                auto ptr = reinterpret_cast<LabelT *>(value);
                delete ptr;
                break;
            }
            case Component_Button: {
                auto ptr = reinterpret_cast<ButtonT *>(value);
                delete ptr;
                break;
            }
            default: break;
        }
        value = nullptr;
        type = Component_NONE;
    }

    inline const Editor::EditorRoot *GetEditorRoot(const void *buf) {
        return flatbuffers::GetRoot<Editor::EditorRoot>(buf);
    }

    inline bool VerifyEditorRootBuffer(
            flatbuffers::Verifier &verifier) {
        return verifier.VerifyBuffer<Editor::EditorRoot>(nullptr);
    }

    inline void FinishEditorRootBuffer(
            flatbuffers::FlatBufferBuilder &fbb,
            flatbuffers::Offset<Editor::EditorRoot> root) {
        fbb.Finish(root);
    }

    inline std::unique_ptr<EditorRootT> UnPackEditorRoot(
            const void *buf,
            const flatbuffers::resolver_function_t *res = nullptr) {
        return std::unique_ptr<EditorRootT>(GetEditorRoot(buf)->UnPack(res));
    }

}  // namespace Editor

#endif  // FLATBUFFERS_GENERATED_EDITORROOT_EDITOR_H_
